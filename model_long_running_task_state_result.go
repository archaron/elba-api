/*
Elba Public API

  ## С чего начать    Для работы с API нужно выпустить API-ключ — уникальный токен, позволяющий авторизовывать ваши запросы в API Контур.Эльбы.    #### Как получить API-ключ    1. Откройте Эльбу, в верхнем правом углу нажмите «Настройки и оплата» → «Настройки сервиса».  2. Перейдите на вкладку «API».  2. Нажмите на кнопку «Выпустить ключ». После этого откроется окно со сгенерированным API-ключом.  3. В открывшемся окне появится ваш API-ключ. Скопируйте и сохраните его в надежном месте, потому что он будет показан только один раз. Это сделано в целях безопасности — мы не храним ключи на своей стороне.

API version: v1
Contact: e@kontur.ru
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package elba

import (
	"encoding/json"
	"gopkg.in/validator.v2"
	"fmt"
)

// LongRunningTaskStateResult - Результат операции. Заполнен, если операция обработана без ошибок
type LongRunningTaskStateResult struct {
	CreateProductTaskResult *CreateProductTaskResult
	SearchContractorsTaskResult *SearchContractorsTaskResult
	SearchProductsTaskResult *SearchProductsTaskResult
	UpdateProductTaskResult *UpdateProductTaskResult
}

// CreateProductTaskResultAsLongRunningTaskStateResult is a convenience function that returns CreateProductTaskResult wrapped in LongRunningTaskStateResult
func CreateProductTaskResultAsLongRunningTaskStateResult(v *CreateProductTaskResult) LongRunningTaskStateResult {
	return LongRunningTaskStateResult{
		CreateProductTaskResult: v,
	}
}

// SearchContractorsTaskResultAsLongRunningTaskStateResult is a convenience function that returns SearchContractorsTaskResult wrapped in LongRunningTaskStateResult
func SearchContractorsTaskResultAsLongRunningTaskStateResult(v *SearchContractorsTaskResult) LongRunningTaskStateResult {
	return LongRunningTaskStateResult{
		SearchContractorsTaskResult: v,
	}
}

// SearchProductsTaskResultAsLongRunningTaskStateResult is a convenience function that returns SearchProductsTaskResult wrapped in LongRunningTaskStateResult
func SearchProductsTaskResultAsLongRunningTaskStateResult(v *SearchProductsTaskResult) LongRunningTaskStateResult {
	return LongRunningTaskStateResult{
		SearchProductsTaskResult: v,
	}
}

// UpdateProductTaskResultAsLongRunningTaskStateResult is a convenience function that returns UpdateProductTaskResult wrapped in LongRunningTaskStateResult
func UpdateProductTaskResultAsLongRunningTaskStateResult(v *UpdateProductTaskResult) LongRunningTaskStateResult {
	return LongRunningTaskStateResult{
		UpdateProductTaskResult: v,
	}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *LongRunningTaskStateResult) UnmarshalJSON(data []byte) error {
	var err error
	// this object is nullable so check if the payload is null or empty string
	if string(data) == "" || string(data) == "{}" {
		return nil
	}

	match := 0
	// try to unmarshal data into CreateProductTaskResult
	err = newStrictDecoder(data).Decode(&dst.CreateProductTaskResult)
	if err == nil {
		jsonCreateProductTaskResult, _ := json.Marshal(dst.CreateProductTaskResult)
		if string(jsonCreateProductTaskResult) == "{}" { // empty struct
			dst.CreateProductTaskResult = nil
		} else {
			if err = validator.Validate(dst.CreateProductTaskResult); err != nil {
				dst.CreateProductTaskResult = nil
			} else {
				match++
			}
		}
	} else {
		dst.CreateProductTaskResult = nil
	}

	// try to unmarshal data into SearchContractorsTaskResult
	err = newStrictDecoder(data).Decode(&dst.SearchContractorsTaskResult)
	if err == nil {
		jsonSearchContractorsTaskResult, _ := json.Marshal(dst.SearchContractorsTaskResult)
		if string(jsonSearchContractorsTaskResult) == "{}" { // empty struct
			dst.SearchContractorsTaskResult = nil
		} else {
			if err = validator.Validate(dst.SearchContractorsTaskResult); err != nil {
				dst.SearchContractorsTaskResult = nil
			} else {
				match++
			}
		}
	} else {
		dst.SearchContractorsTaskResult = nil
	}

	// try to unmarshal data into SearchProductsTaskResult
	err = newStrictDecoder(data).Decode(&dst.SearchProductsTaskResult)
	if err == nil {
		jsonSearchProductsTaskResult, _ := json.Marshal(dst.SearchProductsTaskResult)
		if string(jsonSearchProductsTaskResult) == "{}" { // empty struct
			dst.SearchProductsTaskResult = nil
		} else {
			if err = validator.Validate(dst.SearchProductsTaskResult); err != nil {
				dst.SearchProductsTaskResult = nil
			} else {
				match++
			}
		}
	} else {
		dst.SearchProductsTaskResult = nil
	}

	// try to unmarshal data into UpdateProductTaskResult
	err = newStrictDecoder(data).Decode(&dst.UpdateProductTaskResult)
	if err == nil {
		jsonUpdateProductTaskResult, _ := json.Marshal(dst.UpdateProductTaskResult)
		if string(jsonUpdateProductTaskResult) == "{}" { // empty struct
			dst.UpdateProductTaskResult = nil
		} else {
			if err = validator.Validate(dst.UpdateProductTaskResult); err != nil {
				dst.UpdateProductTaskResult = nil
			} else {
				match++
			}
		}
	} else {
		dst.UpdateProductTaskResult = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.CreateProductTaskResult = nil
		dst.SearchContractorsTaskResult = nil
		dst.SearchProductsTaskResult = nil
		dst.UpdateProductTaskResult = nil

		return fmt.Errorf("data matches more than one schema in oneOf(LongRunningTaskStateResult)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("data failed to match schemas in oneOf(LongRunningTaskStateResult)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src LongRunningTaskStateResult) MarshalJSON() ([]byte, error) {
	if src.CreateProductTaskResult != nil {
		return json.Marshal(&src.CreateProductTaskResult)
	}

	if src.SearchContractorsTaskResult != nil {
		return json.Marshal(&src.SearchContractorsTaskResult)
	}

	if src.SearchProductsTaskResult != nil {
		return json.Marshal(&src.SearchProductsTaskResult)
	}

	if src.UpdateProductTaskResult != nil {
		return json.Marshal(&src.UpdateProductTaskResult)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *LongRunningTaskStateResult) GetActualInstance() (interface{}) {
	if obj == nil {
		return nil
	}
	if obj.CreateProductTaskResult != nil {
		return obj.CreateProductTaskResult
	}

	if obj.SearchContractorsTaskResult != nil {
		return obj.SearchContractorsTaskResult
	}

	if obj.SearchProductsTaskResult != nil {
		return obj.SearchProductsTaskResult
	}

	if obj.UpdateProductTaskResult != nil {
		return obj.UpdateProductTaskResult
	}

	// all schemas are nil
	return nil
}

type NullableLongRunningTaskStateResult struct {
	value *LongRunningTaskStateResult
	isSet bool
}

func (v NullableLongRunningTaskStateResult) Get() *LongRunningTaskStateResult {
	return v.value
}

func (v *NullableLongRunningTaskStateResult) Set(val *LongRunningTaskStateResult) {
	v.value = val
	v.isSet = true
}

func (v NullableLongRunningTaskStateResult) IsSet() bool {
	return v.isSet
}

func (v *NullableLongRunningTaskStateResult) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableLongRunningTaskStateResult(val *LongRunningTaskStateResult) *NullableLongRunningTaskStateResult {
	return &NullableLongRunningTaskStateResult{value: val, isSet: true}
}

func (v NullableLongRunningTaskStateResult) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableLongRunningTaskStateResult) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


